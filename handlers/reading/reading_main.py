import asyncio
from asyncio.log import logger

from aiogram import Router, F, Dispatcher
from aiogram.exceptions import TelegramBadRequest
from aiogram.fsm.context import FSMContext
from aiogram.types import CallbackQuery

from core import config
from core.constants import ACTIVE_QUESTION_KEY, MAX_ATTEMPTS
from core.content_config import CATEGORIES
from core.database.init_db import AsyncSessionLocal
from core.decorators.approved_user_only import is_approved_user
from core.decorators.block import async_with_generating_flag
from core.models.reading_state import ReadingState
from core.services.clients.redis_client import redis_client
from core.services.reading.reading_result import save_card_and_notify
from core.services.reading.reading_service import prepare_next_question, prepare_first_question, \
    has_exceeded_daily_limit
from core.services.users.user_flags import delete_blocking_message
from core.services.users.user_progress import accuracy
from core.utils.guards import block_if_pending_message
from handlers import ui
from handlers.ui.ui_main import reading, topics_kb, categories_kb

router = Router()


@router.callback_query(F.data.startswith("T|"))
@is_approved_user()
@async_with_generating_flag(lambda call, is_approved, state, dispatcher: call.from_user.id, kind="text")
async def questions_handler(call: CallbackQuery, is_approved: bool, state: FSMContext, dispatcher):
    # await call.answer()
    data = await state.get_data()
    category = data.get("category")

    theme = call.data.split("|", 1)[1].strip()

    # if await block_if_pending_message(call.message, state):
    #     return

    async with AsyncSessionLocal() as session:
        if await has_exceeded_daily_limit(session, call.from_user.id, theme):
            # 1) –ø–æ–∫–∞–∑—ã–≤–∞–µ–º alert (–∂–¥—ë–º –∑–∞–≤–µ—Ä—à–µ–Ω–∏—è —ç—Ç–æ–≥–æ –∑–∞–ø—Ä–æ—Å–∞)
            await call.answer(
                f"‚ùó–¢—ã –æ—Ç–≤–µ—Ç–∏–ª –Ω–∞ –≤—Å–µ –≤–æ–ø—Ä–æ—Å—ã –ø–æ —ç—Ç–æ–π —Ç–µ–º–µ.\nü¶∏üèª –ü–æ–ø—Ä–æ–±—É–π –∑–∞–≤—Ç—Ä–∞",
                show_alert=True,
                cache_time=0,  # –Ω–∞ –≤—Å—è–∫–∏–π —Å–ª—É—á–∞–π —Å–±—Ä–æ—Å –∫—ç—à–∞
            )
            # 2) –Ω–µ–±–æ–ª—å—à–∞—è ¬´–ø–µ—Ä–µ–¥—ã—à–∫–∞¬ª, —á—Ç–æ–±—ã Telegram —É—Å–ø–µ–ª –æ—Ç–æ–±—Ä–∞–∑–∏—Ç—å –æ–∫–æ—à–∫–æ
            await asyncio.sleep(0.5)

            # 3) —Ç–µ–ø–µ—Ä—å —à–ª—ë–º –º–µ–Ω—é
            category_name = get_category_by_theme(theme)
            if category_name:
                await call.message.edit_text(
                    f"üìÇ {category_name}\n\n–í—ã–±–µ—Ä–∏—Ç–µ —Ç–µ–º—É:",
                    reply_markup=topics_kb(category_name)
                )
            else:
                await call.message.edit_text(
                    "üìÇ –í—ã–±–µ—Ä–∏—Ç–µ —Ä–∞–∑–¥–µ–ª:",
                    reply_markup=categories_kb()
                )
            return
    await call.answer()
    await redis_client.set(ACTIVE_QUESTION_KEY.format(user_id=call.from_user.id), 1, ex=600)
    await call.message.edit_text("‚úçÔ∏è –ì–µ–Ω–µ—Ä–∏—Ä—É—é —Ç–µ–∫—Å—Ç‚Ä¶", protect_content=True)
    try:
        reading_state = await prepare_first_question(call.from_user.id, category, theme)
        await delete_blocking_message(dispatcher["redis"], call.from_user.id, call.message.bot, call.message.chat.id)
    except RuntimeError as err:
        await call.message.edit_text(str(err))
        return

    # —Å–æ—Ö—Ä–∞–Ω—è–µ–º –≤—Å—ë –≤ FSM
    await state.update_data(**reading_state.__dict__)

    # –£–¥–∞–ª—è–µ–º —Å—Ç–∞—Ä–æ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ-–∑–∞–≥–ª—É—à–∫—É
    try:
        await call.bot.delete_message(
            chat_id=call.message.chat.id,
            message_id=call.message.message_id
        )
    except:
        pass

    # –°–æ–∑–¥–∞—ë–º **–Ω–æ–≤–æ–µ** —Å–æ–æ–±—â–µ–Ω–∏–µ —Å –∑–∞—â–∏—Ç–æ–π –∏ –ø–æ–ª–Ω—ã–º —Ç–µ–∫—Å—Ç–æ–º
    gen_msg = await call.bot.send_message(
        chat_id=call.message.chat.id,
        text=reading_state.full_text,
        protect_content=True
    )
    # –ø–µ—Ä–µ–¥ –ø–æ–∫–∞–∑–æ–º –ø–µ—Ä–≤–æ–≥–æ –≤–æ–ø—Ä–æ—Å–∞
    keyboard, shuffled_options = reading(reading_state.qa[0]["options"])
    await state.update_data(reading_options=shuffled_options)

    # –ø–æ–∫–∞–∑—ã–≤–∞–µ–º –ø–µ—Ä–≤—ã–π –≤–æ–ø—Ä–æ—Å
    try:
        await call.bot.send_message(
            chat_id=call.message.chat.id,
            text=f"<b>{reading_state.qa[0]["question"]}</b>",
            protect_content=True,
            reply_markup=keyboard,
            parse_mode="HTML"
        )

    except TelegramBadRequest as err:
        if "BUTTON_DATA_INVALID" in err.message:
            logger.error("–ù–µ–≤–µ—Ä–Ω—ã–π callback_data –≤ –∫–Ω–æ–ø–∫–µ: %s", err)
            await call.answer("–ü—Ä–æ–∏–∑–æ—à–ª–∞ –≤–Ω—É—Ç—Ä–µ–Ω–Ω—è—è –æ—à–∏–±–∫–∞ —Å –∫–Ω–æ–ø–∫–∞–º–∏. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ —Å–Ω–æ–≤–∞.")
        else:
            raise


@router.callback_query(F.data.startswith("OPT|"))
@is_approved_user()
async def answer_handler(call: CallbackQuery, is_approved: bool, state: FSMContext, dispatcher: Dispatcher):
    # await call.answer()
    data = await state.get_data()
    chosen_idx = int(call.data.split("|", 1)[1])
    options = data['reading_options']
    chosen = options[chosen_idx]

    # –û—Å—Ç–∞–ª—å–Ω—ã–µ –ø–æ–ª—è ‚Äî –¥–ª—è reading_state
    reading_data = {k: v for k, v in data.items() if k not in ('reading_options', 'category')}
    reading_state = ReadingState(**reading_data)

    if chosen == reading_state.correct:
        await accuracy(reading_state.uid, True)
        await save_card_and_notify(call, state, reading_state, dispatcher)
        return

    # –ï—Å–ª–∏ –¥–æ—à–ª–∏ —Å—é–¥–∞ ‚Äî –æ—Ç–≤–µ—Ç –Ω–µ–≤–µ—Ä–Ω—ã–π
    await accuracy(reading_state.uid, False)
    reading_state.wrong += 1

    # –ï—Å–ª–∏ –æ—à–∏–±–æ–∫ >= –ª–∏–º–∏—Ç–∞ (–Ω–∞–ø—Ä–∏–º–µ—Ä, 2) ‚Äî —Ñ–∏–Ω–∞–ª
    if reading_state.wrong >= MAX_ATTEMPTS:
        await save_card_and_notify(call, state, reading_state, dispatcher)
        return

    # –ù–µ –¥–æ—Å—Ç–∏–≥–ª–∏ –ª–∏–º–∏—Ç–∞ –æ—à–∏–±–æ–∫ ‚Äî –∑–∞–¥–∞—ë–º —Å–ª–µ–¥—É—é—â–∏–π –≤–æ–ø—Ä–æ—Å
    await state.update_data(wrong=reading_state.wrong)
    await prepare_next_question(call, state, reading_state)


def get_category_by_theme(theme):
    for category, topics in CATEGORIES.items():
        for t in topics:
            if t[0] == theme:
                return category
    return None
